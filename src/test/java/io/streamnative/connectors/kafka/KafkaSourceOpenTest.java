/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package io.streamnative.connectors.kafka;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import io.streamnative.tests.common.framework.SystemTestRunner;
import io.streamnative.tests.common.framework.SystemTestRunner.TestSuiteClass;
import io.streamnative.tests.pulsar.service.PulsarService;
import lombok.Cleanup;
import lombok.extern.slf4j.Slf4j;
import org.apache.pulsar.client.admin.PulsarAdminException;
import org.apache.pulsar.client.admin.PulsarAdminException.NotFoundException;
import org.apache.pulsar.common.partition.PartitionedTopicMetadata;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.testcontainers.utility.Base58;

/**
 * Integration test to test different variants for opening a source.
 */
@RunWith(SystemTestRunner.class)
@TestSuiteClass(KafkaSourceTestSuite.class)
@Slf4j
public class KafkaSourceOpenTest extends KafkaSourceTestBase {

    public KafkaSourceOpenTest(PulsarService service) {
        super(service);
    }

    /**
     * Current version doesn't support 1 partition use case.
     */
    @Ignore
    public void testKafkaTopicAutoCreationPulsarTopicCreateIfMissing() throws Exception {
        final String topic = "kafka-topic-auto-creation" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);

        @Cleanup
        KafkaSource source = new KafkaSource();
        source.open(config.toConfigMap(), ctx);

        // check the topic is create automatically
        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(1, metadata.partitions);
    }

    @Test
    public void testCreatePulsarTopicIfMissing() throws Exception {
        final String topic = "test-create-pulsar-topic-if-missing-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);

        final int numPartitions = 4;

        createKafkaTopic(topic, numPartitions);

        @Cleanup
        KafkaSource source = new KafkaSource();
        source.open(config.toConfigMap(), ctx);

        // check the topic is create automatically
        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(numPartitions, metadata.partitions);
    }

    @Test
    public void testCreatePulsarTopicIfMissingDisabled() throws Exception {
        final String topic = "test-create-pulsar-topic-if-missing-disabled-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);
        config.pulsar().create_topic_if_missing(false);

        final int numPartitions = 4;

        createKafkaTopic(topic, numPartitions);

        try (KafkaSource source = new KafkaSource()) {
            source.open(config.toConfigMap(), ctx);
            fail("Should fail to start kafka source if create_topic_if_missing is disabled");
        } catch (PulsarAdminException pae) {
            assertTrue(pae instanceof NotFoundException);
        }

        // check the topic is not created
        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(0, metadata.partitions);
    }

    @Test
    public void testAllowDifferentNumPartitions() throws Exception {
        final String topic = "test-allow-different-num-partitions-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);
        config.pulsar().create_topic_if_missing(false);
        config.pulsar().allow_different_num_partitions(true);
        config.pulsar().update_partitions_if_inconsistent(false);

        final int numKafkaPartitions = 4;
        final int numPulsarPartitions = 5;

        createKafkaTopic(topic, numKafkaPartitions);
        admin.topics().createPartitionedTopic(topic, numPulsarPartitions);

        KafkaSource source = new KafkaSource();
        source.open(config.toConfigMap(), ctx);

        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(numPulsarPartitions, metadata.partitions);
    }

    @Test
    public void testUpdatePartitionsIfInconsistentWithLessPartitions() throws Exception {
        final String topic = "test-update-partitions-if-inconsistent-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);
        config.pulsar().create_topic_if_missing(false);
        config.pulsar().allow_different_num_partitions(true);
        config.pulsar().update_partitions_if_inconsistent(true);

        final int numKafkaPartitions = 8;
        final int numPulsarPartitions = 5;

        createKafkaTopic(topic, numKafkaPartitions);
        admin.topics().createPartitionedTopic(topic, numPulsarPartitions);

        KafkaSource source = new KafkaSource();
        source.open(config.toConfigMap(), ctx);

        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(numKafkaPartitions, metadata.partitions);
    }

    @Test
    public void testUpdatePartitionsIfInconsistentWithMorePartitions() throws Exception {
        final String topic = "test-update-partitions-if-inconsistent-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);
        config.pulsar().create_topic_if_missing(false);
        config.pulsar().allow_different_num_partitions(true);
        config.pulsar().update_partitions_if_inconsistent(true);

        final int numKafkaPartitions = 5;
        final int numPulsarPartitions = 8;

        createKafkaTopic(topic, numKafkaPartitions);
        admin.topics().createPartitionedTopic(topic, numPulsarPartitions);

        KafkaSource source = new KafkaSource();
        source.open(config.toConfigMap(), ctx);

        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(numPulsarPartitions, metadata.partitions);
    }

    @Test
    public void testDisallowDifferentNumPartitions() throws Exception {
        final String topic = "test-disallow-different-num-partitions-" + Base58.randomString(8);

        KafkaSourceConfig config = newKafkaSourceConfig();
        config.kafka().topic(topic);
        config.pulsar().create_topic_if_missing(false);
        config.pulsar().allow_different_num_partitions(false);
        config.pulsar().update_partitions_if_inconsistent(false);

        final int numKafkaPartitions = 4;
        final int numPulsarPartitions = 5;

        createKafkaTopic(topic, numKafkaPartitions);
        admin.topics().createPartitionedTopic(topic, numPulsarPartitions);

        try {
            KafkaSource source = new KafkaSource();
            source.open(config.toConfigMap(), ctx);
            fail("Should fail to start kafka source if disallowing different number of partitions");
        } catch (IllegalArgumentException iae) {
            // expected
        }

        PartitionedTopicMetadata metadata = admin.topics().getPartitionedTopicMetadata(topic);
        assertEquals(numPulsarPartitions, metadata.partitions);
    }

}
